# link

1. 链接后的文件可以被 `加载` 到内存并执行。
2. 链接可以执行于 `编译时(compile time)`，也可以执行于 `加载时（load time）`，甚至是 `运行时（runtime time）`
3. `编译时（compile time)` 就是源代码被翻译成机器码
4. `加载时（load time）` 就是程序被加载器加载到内存并执行时
5. `运行时（runtime time)` 就是由应用程序来执行

## linker

1. 链接器（linker）的存在，使得我们在改变模块中的一个时，只需要重新编译它，**并重新链接应用**， 而不必重新编译其他文件。

## 7.1 compiler driver

1. compiler driver 会调用我们的预处理器、编译器、汇编器和链接器中的某一个；
2. 当我们执行 `g++ -Og -o prog main.cpp sum.cpp` 时，整个过程是这样的
    2.1 驱动程序通过预编译器生成 main.i
    2.2 驱动程序通过编译器生成 main.s
    2.3 驱动程序通过汇编器生成 main.o
    2.4 sum.cpp 也通过上面的步骤生成了 sum.o
    2.5 随后通过 linker（链接器程序 ld），将 main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个 `可执行文件（executable object file）`。
    
    
## 7.2 static linker

**为了构造可执行文件，链接器必须完成两个主要任务**

1. `符号解析（symbol resolution）`：目标文件定义和引用符号，**每个符号对应于一个函数、全局变量或者静态变量**，符号解析的目的是将每个 `符号引用` 和 `符号定义` 关联起来。
2. `重定位（relocation）`：编译器和汇编器生成从地址 0 开始的代码和 section。链接器通过把每个 `符号定义` 与一个 `内存位置` 关联起来，从而重定位这些 section，然后修改所有对这些符号的引用，使得它们指向这个内存的位置。
3. 目标文件是纯粹字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。

## 7.3 目标文件

1. 可重定位目标文件
2. 可执行目标文件
3. 共享目标文件

## 7.5 符号和符号表

1. 每个可重定位的目标模块 m 都有一个符号表，包含了 m 定义和引用的符号信息
    1.1 全局符号：由 m 定义并能被其他模块引用的符号
    1.2 外部符号：由其他模块定义并被 m 引用的
    1.3 局部符号：只被模块 m 定义和引用的，对应于带上 static 的函数和全局变量。在 m 中任意位置可见，但不能被其他模块引用
2. 本地链接器符号和局部变量不一样， `.symtab` 中的符号表不包括任何对应于本地费静态程序变量的任何符号，这些符号在运行时在栈中被管理

### 符号表数据结构

```c++
// csapp 469
typedef struct {
    int name;
    char type:4,
         binding:4;
    char reserved;
    short section;
    long value;
    long size;
} Elf64_Symbol;
```
