# 异常控制流

1. ECF 发生在计算器系统的各个层次
2. C++，Java 之类的语言的异常是一种应用层的 ECF，在 C 中是通过 setjmp 和 longjmp 函数提供的。

## 8.1 异常

1. 在处理器中，状态被编码为不同的位和信号。状态变化称之为 `事件`
2. 当处理器检测到有 `事件` 发生时，会通过 `异常表` 的跳转表进行一次间接过程调用，到一个专门设计来处理这类事件的操作系统子程序

### 8.1.1 异常处理

1. 每个异常都分配了一个非负整数的异常号
2. 在操作系统启动时，会初始化一个异常表，table[k] -> 异常 k 的处理程序
3. 在运行时，处理器检测到了一个事件并确定了异常的编号 k，就可以去调用 table[k] 的处理程序

### 8.2.2  异常的类别

1. 中断：例如键盘的输入就属于一种硬件中断，它是异步的；
2. trap 和系统调用：系统调用会导致一个到异常处理程序的 trap，这个处理程序解析参数，并调用适当的内核程序
3. 故障：故障可能会跳转到一个程序去试图修复故障，修复成功则跳回到引起故障的指令，否则执行 abort 退出程序。例如缺页异常就是一个典型的故障。
4. 终止：终止是不可恢复的致命故障引起的，一般是硬件错误

## 8.2 进程

1. 异常为我们进程的实现提供了可能；
2. 进程提供了独立的逻辑控制流，好像我们的进程独占处理器；
3. 进程提供了私有的地址空间，好像我们的程序独占使用内存系统；

### 8.2.4 用户模式和内核模式

1. 处理器通过一个寄存器的模式来控制，当设置了这个标志位之后，进程就运行在内核态中 -- 可以执行指令集中的所有指令，访问内存中的任意位置
2. linux 可以通过 `/proc` 来访问内核数据结构的内容

## 8.4 进程控制

1. 使用 `fork()` 可以创建新的进程，新进程得到父进程用户级的虚拟空间相同并且独立的一份副本，包括代码和数据段、堆、共享库以及用户栈。
2. `fork()` 只会调用一次，但是会返回两次。一次在父进程中，返回子进程的 pid，一次在子进程中，返回父进程的 pid

```c++
#include "iostream"
#include "../8.2/m_fork.cpp"

int main()
{
    pid_t pid;
    int   x = 1;
    printf("parent: pid = [%d]\n", getpid());

    pid = Fork();
    if (pid == 0)
    {
        printf("child : pid = [%d] : x = [%d]\n", getpid(), ++x);
    }

    printf("parent: pid = [%d] : x = [%d]\n", getpid(), --x);
    exit(0);
}
```

>parent: pid = [60828]
>parent: pid = [60828] : x = [0]
>child : pid = [60829] : x = [2]
>parent: pid = [60829] : x = [1]
