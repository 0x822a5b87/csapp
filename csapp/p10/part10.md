# 系统级 IO


## 10.1 Unix i/o

1. 所有的 I/O 设备都被模型化为文件，而输入和输出都被当做相应的文件读和写来执行。这是对 I/O 设备的一种抽象
2. `打开文件` ： 打开文件会返回一个 fd，后续可以通过 fd 来标志某个特定文件，shell 创建的每个进程默认都打开了三个文件：标准输入，标准输出，标准错误
3. `改变当前的文件位置` ： k 指向当前位置，打开时默认为 0，可以通过 seek 来移动
4. `读写文件` ： 读操作就是从文件复制到内存，写操作就是将文件写入到内存
5. 关闭文件

## 10.4 读和写文件

```c++
//
// Created by 杜航宇 on 2019/12/10.
//

#include <fcntl.h>
#include <unistd.h>
#include <printf.h>

int main()
{
    const unsigned int buf_size = 128;
    char *buf = new char[buf_size];

    int fd = open(__FILE__, O_RDONLY);
    ssize_t read_size;
    while ((read_size = read(fd, buf, buf_size)) > 0)
    {
        write(STDOUT_FILENO, buf, read_size);
        // 下面这种是错误的，当缓冲区不包含 buf_size 个字符时将打印错误的字符
        //write(STDOUT_FILENO, buf, buf_size);
    }
    if (read_size != 0)
    {
        printf("read data error : [%lu]\n", read_size);
    }

    close(fd);
}
```

## 10.5 RIO (Robust I/O)

1. RIO 提供 `带应用级缓存的 IO` 和 `不带应用级缓存的 IO`
2. RIO 是 `线程安全` 的

## 10.6 读取文件元数据

1. `stat` 和 `fstat` 哈数可以用来检索文件的信息
2. `sys/stat.h` 重定义了宏来确定 `st_mode` 成员的文件类型：`S_ISREG(m)` 是否为普通文件，`S_ISDIR(m)` 是否为目录文件，`S_ISSOCK(m)` 是否是网络套接字

## 10.8 共享文件

1. 内核用三个数据结构来表示已经打开的文件：`描述符表`， `文件表`，`v-node 表`
2. `描述符表`：
	2.1 进程之间的表相互独立
	2.2 每个表包含了许多的文件描述符，描述符指向 `文件表` 中的一个表项
3. `文件表`
	3.1 文件表所有进程共享
	3.2 可以简单的认为，当我们调用 `open` 即添加一个表项到文件表，当我们调用 `close` 即从文件表删除一个表项
	3.3 文件表包含了文件当前文件指针的位置，引用计数，还有一个指针指向 `v-node 对应表项`
	3.4 **对于一个文件，我们调用两次 open 会在文件表中生成两个表项。但是这两个表项会指向同一个 v-node**
	3.5 **如果一个进程已经有了一个打开的文件，当我们 fork 的时候，会将这个文件的文件表表项的引用计数加一**
4. `v-node`
	4.1 所有进程共享
	4.2 包含了 `stat` 结构中的大多数信息
5. 我们可以认为 **文件表保存了文件中那些相对独立的信息**：例如对于每个进程所处的 offset。而 **v-node则保存了哪些共享的信息。例如最后访问时间，文件大小**

>当我们打开一个文件，首先会通过操作系统初始化所有 v-node 信息，并将 v-node 加入到表。
>随后将创建文件表，文件表的文件指针默认为0，并将 v-node 指针指向我们刚初始化的表项
>随后，创建文件描述符。将描述符指向刚刚创建的表项

### 为什么我们需要 描述符表，文件表，v-node 表三个表结构来描述文件呢

>描述符表是进程独享的，所以我们需要通过描述符表来记录我们进程的文件打开信息；然后为什么我们不用描述符表直接指向我们的 v-node 表呢？因为 v-node 表示的是那些与进程无关的信息，例如大小，最后修改时间这些是与进程无关的。而文件表则保存了一些文件内的信息，这些信息是和进程相关的。

---

## 10.9 I/O 重定向

1. `dup2(oldfd, newfd)` 可以是的 oldfd 指向 newfd 的文件表表项

## 10.10 标准 I/O

1. 标准 I/O 是指的 `fopen`, `fwrite`, `fread` 等方法
2. 标准 I/O 将一个打开的文件抽象为一个 `流`。对于我们而言，一个流就是一个 `FILE *`
