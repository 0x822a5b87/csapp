# 3.1 不光是查找值！“二分搜索”

## 3.1.1 从有序数组中查找某个值

![lower_bound](pic03/lower_bound.png)

```cpp
//
// Created by 0x822a5b87 on 2020/7/10.
//

#include "iostream"

int n, a[100], k;

void init()
{
	std::cin >> n;
	for (size_t i = 0; i < n; ++i)
	{
		std::cin >> a[i];
	}
	std::cin >> k;
}

void solve()
{
	if (n <= 0)
		return;

	int ret = n;
	int b   = 0, e = n - 1;
	while (e - b > 1)
	{
		int mid = (e + b) / 2;
		std::cout << 0 << " " << e << std::endl;
		if (a[mid] >= k)
		{
			e   = mid;
			ret = mid;
		}
		else
		{
			b = mid;
		}
	}

	std::cout << ret << std::endl;
}

int main(int argc, char **argv)
{
	init();
	solve();
}
```

## 3.1.2 假定一个解并判断是否可行

![cable master](pic03/cable master.png)

```cpp
#include <cmath>
#include "iostream"

// 解题思路
// 假设切割之后每条绳子的长度为 x，那么每条绳子的可以被切割的数量是 n[i] = floor(L[i] / x)
// 那么所有绳子被切割的总长度就是 n[0] + ... n[size - 1]，只要这个数字大于 K 说明满足条件
// 那么现在在 [0, max_len() + 1] 的区间一定就是绳子可以被切割的最大长度
// 我们只需要在这个区间来验证每一个数字是否可以满足条件，直到找到最大的那个满足条件的数字

int n, k;
double len[100];

void init()
{
	std::cin >> n;
	std::cin >> k;
	for (int i = 0; i < n; ++i)
	{
		std::cin >> len[i];
	}
}

bool C(double x)
{
	int num = 0;
	for (int i = 0; i < n; ++i)
	{
		num += static_cast<int>(len[i]) / x;
	}
	return num >= k;
}

double max_len()
{
	double max = 0;
	for (size_t i = 0; i < n; ++i)
	{
		if (len[i] > max)
		{
			max = len[i];
		}
	}
	return max;
}

void solve()
{
	// 上界是 MaxLen
	double lb = 0, ub = max_len() + 1;
	// 循环100次，由于二分法的时间复杂度是 O(lg N)，所以循环 100 次的精度已经很高了
	for (int i = 0; i < 100; ++i)
	{
		double mid = (lb + ub) / 2;
		if (C(mid))
		{
			lb = mid;
		}
		else
		{
			ub = mid;
		}
	}
	printf("%.2f\n", floor(ub * 100) / 100);
}

int main(int argc, char **argv)
{
	init();
	solve();
}
```

## 3.1.3 最大化最小值

![aggressive cows](pic03/aggressive cows.png)

根据题目的描述，我们需要求的值是，我们将 `m` 头牛放到 `n` 个小屋里，输出相邻的两头牛之间的最小距离

>**类似的最大化最小值或者最小化最大值的问题，通常用二分搜索法就可以很好的解决**

根据我们在前面一题里的思路，我们假设最后的两头牛之间的最小距离为 x，**这个最小距离一定在 [0, max_len] 这个区间里**。
那么我们可以使用二分法在所有距离里查找那个最大的满足条件的距离。

```cpp
#include "iostream"

int n, m;
int x[100];

void init()
{
	std::cin >> n >> m;
	for (int i = 0; i < n; ++i)
	{
		std::cin >> x[i];
	}
	// 注意，我们需要对数组排序，因为输入是无序的。
	std::sort(&x[0], &x[n-1]);
}

bool yes(int dis)
{
	int prev = -1000, remaining = m;
	for (int i = 0; i < n && remaining > 0; ++i)
	{
		if (x[i] - prev >= dis)
		{
			// 满足条件就放置一头牛
			--remaining;
			prev = x[i];
		}
	}

	return remaining == 0;
}

void solve()
{
	int lb = 0, ub = x[n - 1];
	while (ub - lb > 1)
	{
		int mid = (lb + ub) / 2;
		if (yes(mid))
		{
			lb = mid;
		}
		else
		{
			ub = mid;
		}
	}
	std::cout << lb << std::endl;
}

int main(int argc, char **argv)
{
	init();
	solve();
}
```
